When addressing a point from the reviews, please remove it from this todo file,
and commit in the same patch.

----------------------- REVIEW 2 ---------------------

The authors show that the detected SCoPs are largest than with previous
techniques. It would be interesting to know the impact on the overall
compilation time (including polyhedral code generation) wrt the efficiency of
the code generated, to estimate whether the additional SCoPs or SCoP parts lead
to execution time gains and don't affect too much the compilation time. On the
Polybench, the authors report a compilation slowdown for SCoP detection which
leads to more interesting SCoPs, but there is no quantified results. If the
authors could give these results in the final version of the paper, it would be
very interesting.


Detailed comments:
==================

Check overfull hboxes.

Section 3:
----------

Figure 2:

Add line numbers so that you can refer to them in Section 3.1.

Section 5:

2- It seems to me that in most cases the sets of natural loops which have good
chances of being identified as SCoPs are well-formed loops in the program AST,
not separated by any weird control flow due to gotos, returns, ... Wouldn't it
be more effective to perform the analysis on an even higher-level
representation, closer to the AST (I have in mind for instance PIPS's HCFG,
which retains the AST whenever possible and switches to a local CFG otherwise)?
This of course may also depend on how other analyses (such as pointer analyses
and alias analyses) results are available...


----------------------- REVIEW 3 ---------------------

the document lacks
information about the original design and implementation choices behind GCC's
current SCoP detection mechanism, which would be insightful (since the authors
have a deep knowledge about its development).

-- Introduction --

Some argument on why conservative SCoP detection as in [2] results in large
overheads may strengthen the motivation for the current work. In particular, it
is not clear to me why it would make the SCoP detection itself more expensive as
it relaxes and simplifies SCoP constraints. This is obviously different for
optimization because SCoPs would be larger, but this is another question.

-- A New Faster SCoP Detection --

The algorithm is well described except for the following points.

- More generally, I assume that all CFG or natural loop tree traversal functions
  (a) return NULL if a node is not found and (b) include a recursion bound
  condition when their arguments are NULL, but this is not stated in the paper;
  as this information is not related to the functioning of the algorithms
  themselves, it may be included in, e.g. a figure caption;

If all my assumptions listed above are correct, the algorithm looks fully
operational.


-- Experimental Results --

For PolyBench results in Fig.5, using test case names would be preferable to
assigning integer numbers with unclear mapping.  It may be also interesting to
report the outcome of the SCoP detection along with the speedup/slowdown for
this benchmark, e.g. did the case with ~0.33 speedup resulted in three times
larger SCoPs?

-- Conclusion --

After the motivating introduction, I wonder will, in the end, the polyhedral
optimization be enabled by default in GCC and at which levels?

Similarly, the conclusion leaves profile-guided optimization for the future work
while the abstract makes allusion to “-fprofile-use” flag enabling it.


----------------------- REVIEW 4 ---------------------

The paper’s reliance of SCC components and depths of loops is quite similar to
the approach of Sreedhar-Gao-Lee-TOPLAS-96 who use an additional annotation on
their dominance trees (which they call as “DJ graphs”).  A comparison of the
paper's approach with the above work would be appropriate.

----------------------- REVIEW 6 ---------------------

Here are a few remarks:

 - Since the technique is based on a tree-based representation for loop, how
   different the technique is from those used in source-level polyhedral tools
   such as Pet, Clan, PolyRose, etc.

 - The typesetting for algorithms (figure 2,3,4) make them difficult to follow
   (and ugly!), please use one of the numerous latex algorithm packages to
   improve the rendering. Also, I found the description/explanation of the
   algorithms a bit redundant with the algorithm themselves, and would have
   preferred to have examples instead.

 - Although I understand that the goal of the paper is not to compare against
   polly/llvm, I was a bit frustrated after reading section 4.1. I would have
   appreciated that authors discuss a bit more in details the difference (and
   impact of these difference) between polly and the proposed
   approach. Similarly, the authors should explain with more details how SCOP
   extraction was performed in earlier version of graphite, and why it could not
   benefit from scev (this is a bit unclear).


----------------------- REVIEW 7 ---------------------
The acronym SCoP si incorrect, and should be replaced by either ACLs (Affine
Control Loops) or PWAC (Parts With Affine Control, rhymes with quack :-)

Seb: to confuse people even more, I suggest that we change the title of the
paper to: "ACL -- Austin City Limits: A Fast Tour of an Industrial Compiler City"
