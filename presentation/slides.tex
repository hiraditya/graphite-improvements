\documentclass{beamer}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{graphviz}
\usepackage{tikz}
%\usepackage{auto-pst-pdf}
\usepackage{dot2texi}

\begin{document}
\def \SCoP {SCoP}
\def \GCC {GCC}
\def \LLVM {LLVM}
\def \SESE {SESE}
\def \CFG {CFG}
\def \SSA {SSA}
\def \scev {scev}

\title{\SCoP{} Detection: A Fast Algorithm for Industrial Compilers}
\author{Sebastian Pop and Aditya Kumar}
\institute{SARC: Samsung Austin R\&D Center}
\date{Jan 19, 2016}
%\date{\today}

\frame{\titlepage}

\frame{\frametitle{Outline of the presentation}
  \begin{itemize}
  \item Introduction
  \item Details of algorithm
  \item Experimental results
  \item Conclusion and future work
  \end{itemize}
}

\frame{\frametitle{SCoP Detection (Introduction)}
  \begin{itemize}
  \item Single Entry Single Exit (SESE) regions as Static Controlled Parts (SCoP).
  \item Loop Tree data structure.
  \end{itemize}
}

\begin{frame}[fragile]{Loop Tree Representation of Program}
  \begin{columns}[T,onlytextwidth] % align columns

%%%% -------------- Loop Tree -----------------
    \begin{column}{.4\textwidth}
      Loop Tree
        \begin{tikzpicture}[scale=0.5]
          \begin{dot2tex}[dot,tikz,codeonly,styleonly]
            digraph LT{
              {rank = same; Loop2; Loop3;}
              FunctionEntry -> Loop1 [label="       inner"];
              Loop1 -> Loop2 [label="       inner"];
              Loop2 -> Loop3 [label=" next "];
            }
          \end{dot2tex}
        \end{tikzpicture}
    \end{column}%

%%%% -------------- Program -----------------
    \begin{column}{0.55\textwidth}
      Program
      \begin{verbatim}
      int foo(int N, int M, int P)
      {
        int i, j, k;
        // Loop1
        for (i = 0; i < N; ++i) {
          stmt1;
          // Loop2
          for (j = 0; j < M; ++j)
            stmt2;
          // Loop3
          for (k = 0; k < P; ++k)
            stmt3;
        }
      }
      \end{verbatim}
    \end{column}%

  \end{columns}
\end{frame}

\begin{frame}[fragile]{SESE Region}
\begin{tikzpicture}[scale=0.5]
\begin{dot2tex}[dot,tikz,codeonly,styleonly]
digraph G{
BeforeSESE -> IfCondition;
IfCondition -> TrueRegion;
IfCondition -> LoopHeader;
LoopHeader -> LoopLatch;
LoopLatch -> LoopHeader;
LoopHeader -> EndIf;
TrueRegion -> EndIf;
EndIf -> AfterSESE;
}
\end{dot2tex}
\end{tikzpicture}
\end{frame}


\frame{\frametitle{SCoP Detection (Other implementations)}
  \begin{itemize}
  \item Previous graphite SCoP detection based on CFG and DOM.
  \item Polly's SCoP detection based on analysis of SESE regions.
  \end{itemize}
}

\frame{\frametitle{SCoP Detection (New Algorithm)}
  \begin{itemize}
  \item Focus on structure of natural loops first rather than validity of each statement.
  \item Start with the node of a loop tree rather than beginning of the program.
  \end{itemize}
}

\begin{frame}[fragile]{SCoP Detection (New Algorithm)}
\begin{verbatim}
// Recurse on the loop.inner.
sese build_scop_depth (sese s1, loop l):
  s1 = build_scop_depth (s1, l.inner)
  sese s2 = merge_sese (s1, get_sese (l))
  if (s2 is an invalid scop) {
      // s1 might be a valid scop, so return it
      // and start analyzing from the adjacent loop.
      build_scop_depth (invalid_sese, l.next)
      return s1
  }
  if (l is an invalid scop in s2)
    return build_scop_depth (invalid_sese, l.next)
  return build_scop_breadth (s2, l)
\end{verbatim}
\end{frame}

\begin{frame}[fragile]{SCoP Detection (New Algorithm)}
\begin{verbatim}
// Recurse on loop.next.
sese build_scop_breadth (sese s1, loop l):
  sese s2 = build_scop_depth (invalid_sese, l.next)
  if (s2 is an invalid scop) {
      if (s1 is a valid scop)
        add_scop (s1)
      return s1
  }
  sese combined = merge_sese (s1, s2)
  if (combined is a valid scop)
    s1 = combined
  else
    add_scop (s2)
  if (s1 is a valid scop)
    add_scop (s1)
  return s1
\end{verbatim}
\end{frame}

\frame{\frametitle{When is an \SESE{} region a valid \SCoP{?}}
An \SESE{} region is regarded as a valid \SCoP{} when it satisfies the following
conditions:
\begin{enumerate}
\item The entry basic block should have only one predecessor and the exit
  basic block should have only one successor (i.e., an \SESE{}).
\item The entry should dominate the exit.
\item The exit should post-dominate the entry.
\item All the loops in the \SESE{} should have single exits.
\item The scalar evolution of all memory accesses and conditional expressions
  should be affine.
\item All the statements inside the region should be representable in the
  polyhedral model.
\item The induction variables of all the loops should be of (or convertible to)
  signed integer.
\end{enumerate}
}

\frame{\frametitle{Experimental Results}
\begin{table}[h!]
  \caption{\SCoP{} metrics on Polybench.}
  \begin{center}
    \begin{tabular}{|c|c|c|c|}
      \hline
      Metric                   	& New  & Old  & Polly  \\
      \hline
      \SCoP{s}          		& 34   & 189  & 30     \\
      Max loops/\SCoP{}           	& 17   & 8    & 11     \\
      Min loops/\SCoP{}           	& 2    & 1    & 2      \\
      \SCoP{s} with min loops/\SCoP{} & 7    & 109  & 3      \\
      Loops in \SCoP{s} 		& 207  & 316  & 155    \\
      Loops/\SCoP{}               	& 6.09 & 2.59 & 5.17   \\
      \hline
    \end{tabular}
  \end{center}
  \label{tab:scop-metrics}
\end{table}
}

\frame{\frametitle{Experimental Results}
\begin{table}[h!]
  \caption{Overall number of instructions spent in \SCoP{} detection.}
  \begin{center}
    \resizebox{\linewidth}{!}{
    \begin{tabular}{|c|c|c|c|c|c|c|}
      \hline
      Benchmark  & Old      & New        & Speedup & Main       & Old \% & New \%  \\
      \hline
      Polybench  & $3.3e^8$ & $4.8e^8$   & $0.7$   & $2.5e^{10}$ & $1.4$  & $1.9$   \\
      Tramp3d-v4 & $1.8e^9$ & $6.2e^8$   & $2.8$   & $1.9e^{11}$ & $7.0$  & $0.3$   \\
      \GCC{} 6.0    & $1.5e^{10}$ & $6.7e^8$ & $22.6$  & $6.1e^{12}$ & $0.24$ & $0.01$  \\
      \hline
    \end{tabular}}
  \end{center}
\end{table}
}

\frame{\frametitle{Conclusion and Future work}
  Conclusion
  \begin{itemize}
  \item New algorithm for SCoP detection.
  \item Comparative analysis to show compile time improvement.
  \end{itemize}

  Future Work
  \begin{itemize}
  \item SCoP detection should drive polyhedral optimization.
  \item Using profile information to tune the SCoP detection.
  \end{itemize}
}


\end{document}
